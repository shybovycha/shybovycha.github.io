<meta name="layout" content="post">
<meta name="title" content="Speeding-up algorithms with SSE">
<meta name="date" content="2017-02-21T17:59:54+02:00">
<meta name="tags" content="rtfm,tutorial,assembly,c++,sse">
<meta name="tumblr_url" content="http://shybovycha.tumblr.com/post/122400740651/speeding-up-algorithms-with-sse">
<p>Have you ever asked anyone if assembly language might be useful nowadays? So, here’s the short answer: <strong>YES</strong>. When you know how your computer works <u>(not a processor itself, but the whole thing - memory organization, math co-processor and others)</u>, you may optimize your code while writing it. In this short article, I shall try to show you some use cases of optimizations, which you may incorporate with the usage of low-level programming.</p>

<p>Recently I was reading through my old posts and found out there is a gap in the article about SSE - the post did not cover some of the implementation caveats. I decided to fulfill this and re-publish a new version.</p>

<!--more-->

<h2>Finding maximum</h2>

<p>So, let’s start-off searching a maximum element in the array. Usually, it is nothing just iterating through the array, comparing each element with some starting value. For optimization reason and for the precision’s sake we set the initial value to the first array’s element. Like this:</p>
<span class="kt">float</span> <span class="nf">max_value</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">res</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">res</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<h2>Index-based search</h2>

<p>What we could do firstly is to store not the search element itself, but its index:</p>
<span class="kt">float</span> <span class="nf">max_index</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">res</span><span class="p">])</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">res</span><span class="p">];</span>
<span class="p">}</span>

<p>This naive optimization has its effect <u>(time in seconds; the value found in braces)</u>:</p>
Value-based: 0.00732200 (0.99999827)
Index-based: 0.00674200 (0.99999827)

<h2>Vector operations</h2>

<p>This is quite a universal algorithm, which could be used for any type, which allows comparing. But let’s think abotu how we can speed up that code. First of all, we could split the array into pieces and find maximum among them.</p>

<p>There is a technology, allowing that. It is called <strong>SIMD</strong> - <strong>S</strong>ingle <strong>I</strong>nstruction - <strong>M</strong>ultiple <strong>D</strong>ata Stream. Simply saying, it means dealing with multiple data pieces <u>(cells, variables, elements)</u> with the use of a single processor’ instruction. This is done in processor command extension called <strong>SSE</strong>.</p>

<p><strong>Note:</strong> your processor or even operating system may not support these operations. So, before continuing reading this article, be sure to check if it does. On Unix systems you may look for <code>mmx|sse|sse2|sse3|sse4_1|sse4_1|avx</code> in <code>/proc/cpuinfo</code> file.</p>

<p>SSE extension has a set of vector variables to be used. These variables <u>(on the lowest, assembly level, they are called <code>XMM0</code> .. <code>XMM7</code> registers)</u> allow us for storing and processing 128 bits of data as it was a set of <code>16 char</code>, <code>8 short</code>, <code>4 float/int</code>, <code>2 double</code> or <code>1 128-bit int</code> variables.</p>

<p>But wait! There are other versions of SSE, allowing for different registers of a different size! Check this out:</p>

<p><strong>SIMD extensions</strong></p>

<p><strong>MMX - hot 1997:</strong></p>

<ul>
<li>  only integer items</li>
<li>  vectors have a length of <code>64 bits</code></li>
<li>  8 registers, namely <code>MM0</code>..<code>MM7</code></li>
</ul>

<p><strong>SSE highlights:</strong></p>

<ul>
<li>  only 8 registers</li>
<li>  each register has a size of 128 bit</li>
<li>  70 operations</li>
<li>  allow for floating-point operations and vector’ elements</li>
</ul>

<p><strong>SSE2 features:</strong></p>

<ul>
<li>  adds 8 more registers <u>(so now we have <code>XMM0</code> .. <code>XMM15</code>)</u></li>
<li>  adds 144 more operations</li>
<li>  makes floating-point operations more precise</li>
</ul>

<p><strong>SSE3 changes:</strong></p>

<ul>
<li>  adds 13 more operations</li>
<li>  allows for horizontal vector operations</li>
</ul>

<p><strong>SSE4 advantages:</strong></p>

<ul>
<li>  adds 54 more operations (47 are given by SSE4.1 and 7 more come from SSE4.2)</li>
</ul>

<p><strong>AVX - brand new version:</strong></p>

<ul>
<li>  vector size is now <code>256 bit</code></li>
<li>  registers are renamed to <code>YMMi</code>, while <code>XMMi</code> are the lower 128 bits of <code>YMMi</code></li>
<li>  operations now have three operands - <code>DEST</code>, <code>SRC1</code>, <code>SRC2</code> (<code>DEST = SRC1 op SRC2</code>)</li>
</ul>

<p><strong>SSE operations</strong></p>

<p>So, I mentioned <strong>horizontal vector operations</strong>. But let’s do it in a series.</p>

<p>There are two SSE operation types: <strong>scalar</strong> and <strong>packed</strong>. Scalar operations use only the lowest elements of vectors. Packed operations deal with each element of vectors given. Look at the images below and you shall see the difference:</p>

<div>
    <img data-src="/images/sse-optimizations/addss.png" alt="">
</div>

<div>
    <img data-src="/images/sse-optimizations/addps.png" alt="">
</div>

<div>
    <img data-src="/images/sse-optimizations/addsd.png" alt="">
</div>

<div>
    <img data-src="/images/sse-optimizations/addpd.png" alt="">
</div>

<p>Horizontal operations deal on vectors in a different direction. Instead of operating on elements in the corresponding positions, these operate on elements in adjacent positions:</p>

<div>
    <img data-src="/images/sse-optimizations/haddps.png" alt="">
</div>

<!--more-->

<p>So there are six &quot;types&quot; of operations, as described above. They are:</p>

<ul>
<li>operations, dealing with <strong>scalar</strong> or <strong>double</strong> values</li>
<li>operations, operating on <strong>all elements in a pack</strong> or on <strong>last elements of a pack</strong></li>
<li>operations, handling values on <strong>corresponding</strong> or <strong>adjacent</strong> positions</li>
</ul>

<p>To determine if an operation type, you just need to look at the last two characters of operation’s name:</p>

<p><code>HADDPS</code> -&gt; <code>Horizontal</code> <code>ADD</code> <code>Packed</code> <code>Single-precision</code></p>

<p><strong>Working with SSE</strong></p>

<p>Images above describe how processor instructions <u>(assembly commands)</u> work. To map those onto C++ functions, you only need to replace assembly operation with the corresponding function from SSE headers <u>(I&#39;ll cover that in just a second)</u>. But the main goal of those explanations above was to give you an idea how operations themselves work and where do they store results.</p>

<p>To work with SSE we need to follow these three steps:</p>

<ol>
<li>load data into XMM registers</li>
<li>perform all the operations needed on those XMM registers</li>
<li>store data from XMMs into usual variables</li>
</ol>

<p>To use vector operations, you shall need to have some header files included in your code, as well as compiler flags, turned on.</p>

<p>These are header files:</p>

<ul>
<li><code>mmintrin.h</code> - MMX</li>
<li><code>xmmintrin.h</code> - SSE</li>
<li><code>emmintrin.h</code> - SSE2</li>
<li><code>pmmintrin.h</code> - SSE3</li>
<li><code>smmintrin.h</code> - SSE4.1</li>
<li><code>nmmintrin.h</code> - SSE4.2</li>
<li><code>immintrin.h</code> - AVX</li>
</ul>

<p>None of the header files requires all the previous ones to be included too. Compiler flags are <code>-mmmx</code>, <code>-msse</code>, <code>-msse2</code>, <code>-msse3</code>, <code>-msse4</code>, <code>-mavx</code>, correspondingly. As with header files, none of these flags requires previous ones to be turned on.</p>

<p><strong>Data types</strong></p>

<p>There are three <u>&quot;standard&quot;</u> data types within SSE:</p>

<ol>
<li> <code>__m128</code>, which is SSE’s <code>float[4]</code></li>
<li> <code>__m128d</code> corresponds to <code>double[2]</code></li>
<li> <code>__m128i</code> represents one of these: <code>char[16]</code>, <code>short int[8]</code>, <code>int[4]</code> or <code>uint64_t[2]</code></li>
</ol>

<p>Each of them needs to be converted from or to standard C++ types with its own <strong>intrinsic</strong> (SSE operation).</p>

<p><strong>Intrinsics</strong></p>

<p>SSE operations in C++ are named this way: <code>_mm_{OPERATION}_{SUFFIX}</code>. The <strong>operation</strong> is the operation on vectors you want to perform. The <strong>suffix</strong> is a set of flags for a processor, showing in what way it should work with operands <u>(packed/scalar, single-/double- precision, etc.)</u>.</p>

<p>For optimization’s sake, it is better if operands for intrinsincs are aligned in memory for base 16. But do not worry, the compiler will automatically decide if the variable is aligned or not and perform all the needed operations itself.</p>

<p>For loading data into SSE vectors there are four intrinsics:</p>

<ol>
<li> <code>_mm_set_ps(4.0, 3.0, 2.0, 1.0)</code> -&gt; <code>[4.0, 3.0, 2.0, 1.0]</code></li>
<li> <code>_mm_set1_ps(3.0)</code> -&gt; <code>[3.0, 3.0, 3.0, 3.0]</code></li>
<li> <code>_mm_set_ss(4.0)</code> -&gt; <code>[0.0, 0.0, 0.0, 4.0]</code></li>
<li> <code>_mm_setzero_ps()</code> -&gt; <code>[0.0, 0.0, 0.0, 0.0]</code></li>
</ol>

<p>And like those, there are very similar intrinsics for storing data from vectors in a usual C++ types <u>(in the examples below assume working with the same `</u><u>m128 t = [4.0, 3.0, 2.0, 1.0]`)</u>:</p>

<ol>
<li> <code>_mm_store_ps(float[4], __m128)</code> -&gt; <code>[4.0, 3.0, 2.0, 1.0]</code></li>
<li> <code>_mm_store_ss(float*, __m128)</code> -&gt; <code>1.0</code></li>
<li> <code>_mm_store_ss(float*, __m128)</code> -&gt; <code>[1.0, 1.0, 1.0, 1.0]</code></li>
<li> <code>double _mm_cvtsd_f64(__m128d)</code> -&gt; <code>1.0</code></li>
<li> <code>int _mm_cvtsi128_si32(__m128i)</code> -&gt; <code>1</code> <u>(for given `</u><u>m128i [4, 3, 2, 1]`)</u></li>
</ol>

<p><strong>Finding maximum</strong></p>

<p>So, let’s get back to finding the maximum in an array. For this task we will search maximums on each 4 elements of our array, storing them in the <code>XMMi</code> register:</p>
<span class="kt">float</span> <span class="nf">max_sse</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">__m128</span> <span class="o">*</span><span class="n">f4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__m128</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">__m128</span> <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">f4</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">maxval</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p>But if you run this code, you may notice it returns the maximum, not in 100% of cases. This is because we are storing <strong>four maximums</strong> between <strong>each portion of an array</strong>. So, only one of those four is the maximum. But how can we find the maximum among four numbers? Running a loop seems obvious but not effective enough…</p>

<p>We may use the <code>shuffle</code> intrinsic! That is, cycle-shifting vector three times and finding maximum between that shifted vector and its previous value. That will give us the maximum in all four positions of our vector.</p>

<p>Here is a better explanation:</p>

<p>If we want to cycle-shift a 4-number array, we use <code>_mm_shuffle_ps</code> intrisinc.</p>

<p>It takes 3 parameters: <code>m1</code>, <code>m2</code>, and <code>mask</code>. First two are four-word (four-number) packs. The mask consists of four numbers and shows which elements of pack <code>m2</code> and which elements of pack <code>m1</code> will form the result. This mask could be obtained using <code>_MM_SHUFFLE(z, y, x, w)</code> macro, which forms an integer according to the formula <code>(z &lt;&lt; 6) | (y &lt;&lt; 4) | (x &lt;&lt; 2) | w</code>.</p>

<p>Given those definitions, the call <code>m3 = _mm_shuffle_ps(m1, m2, _MM_SHUFFLE(z, y, x, w))</code> is equal to the formula <code>m3 = (m2(z) &lt;&lt; 6) | (m2(y) &lt;&lt; 4) | (m1(x) &lt;&lt; 2) | m1(w)</code>.</p>

<p>So we want to shift a pack by one element right, like this: <code>[4, 2, 3, 1] =&gt; [2, 3, 1, 4]</code>. We need to pass the initial pack, <code>[4, 2, 3, 1]</code> twice: <code>_mm_shuffle_ps([4, 2, 3, 1], [4, 2, 3, 1], mask)</code> and form a mask, which will use elements <code>[2, 3]</code> for the higher words of a result and elements <code>[3, 1]</code> for the lower words. These elements can be then indexed as follows:</p>
+-----------+---------+
| index     | 3 2 1 0 |
+-----------+---------+
| element   | 4 2 3 1 |
+-----------+---------+

<p>So to get the pair <code>[2, 3]</code> we need elements with indices <code>[2, 1]</code>. And to get the pair <code>[1, 4]</code> we need elements with indices <code>[0, 3]</code>.</p>

<p>Given that, we can use macro <code>_MM_SHUFFLE()</code> to generate the mask: <code>_MM_SHUFFLE(2, 1, 0, 3)</code>. And the final formula looks like this: <code>_mm_shuffle_ps(m1, m2, _MM_SHUFFLE(2, 1, 0, 3))</code>.</p>
+--+---------+
|  | 3 2 1 0 |
+------------+
|m1| 4 2 3 1 |
+------------+
|m2| 4 2 3 1 |
+------------+
|m3| 2 3 1 4 |
+------------+

<p>And our <code>max</code> function in pseudo-code looks like this:</p>
<span class="c1">// given val = [4, 2, 3, 1]</span>
<span class="n">maxval</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
    <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<p>Which will be executed like this:</p>
<span class="c1">// preparation</span>
<span class="n">maxval</span> <span class="o">=</span> <span class="o">[</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// i = 0</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">_mm_shuffle_ps</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">_MM_SHUFFLE</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// = [2, 3, 1, 4]</span>
<span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="o">([</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">])</span> <span class="c1">// = [4, 3, 3, 4]</span>

<span class="c1">// i = 1</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">_mm_shuffle_ps</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">_MM_SHUFFLE</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// = [3, 1, 4, 2]</span>
<span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="o">([</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">])</span> <span class="c1">// = [4, 3, 4, 4]</span>

<span class="c1">// i = 2</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">_mm_shuffle_ps</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">_MM_SHUFFLE</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// = [1, 4, 2, 3]</span>
<span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="o">([</span><span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">],</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">])</span> <span class="c1">// = [4, 4, 4, 4]</span>

<p>The <code>_MM_SHUFFLE(2, 1, 0, 3)</code> call could be expanded to <code>(2 &lt;&lt; 6) | (1 &lt;&lt; 4) | (0 &lt;&lt; 2) | 3</code>, which equals to <code>147</code> or <code>0x93</code> in HEX.</p>

<p>And here is the final C++ implementation:</p>
<span class="kt">float</span> <span class="nf">max_sse</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">__m128</span> <span class="o">*</span><span class="n">f4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__m128</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">__m128</span> <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">f4</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_ps</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">maxval</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p><strong>And how about integers?</strong></p>

<p>The code for finding maximum with SSE among integer array is very, very similar to the previous one - you just need to decorate intrinsics with a different prefix and change store operation:</p>
<span class="kt">int</span> <span class="nf">max_sse_int</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">__m128i</span> <span class="o">*</span><span class="n">f4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__m128i</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">__m128i</span> <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_epi32</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">f4</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="n">_mm_max_epi32</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">_mm_shuffle_epi32</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_mm_cvtsi128_si32</span><span class="p">(</span><span class="n">maxval</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p><strong>Profit?</strong></p>

<p>If we compare the results of all three methods - usual loop, index-based searching and SSE, we may see something like this <u>(I ran these tests on my laptop’s i7 processor on one million random float/int values)</u>:</p>

=== Looking for a maximum element in a list of 1000000 floats ===
* Value-based: 0.00382500 sec; max = 0.99999923
* Index-based: 0.00282200 sec; max = 0.99999923
* SSE: 0.00131300 sec; max = 0.99999923
=== Looking for a maximum element in a list of 1000000 integers ===
* Value-based: 0.00384200 sec; max = 99
* Index-based: 0.00298300 sec; max = 99
* SSE: 0.00130400 sec; max = 99


<p>Here you can see that index-based searching gives some speeding-up (around <code>15%</code>). But the real speed boost is gained with SSE (almost <strong><code>4 times</code></strong>!).</p>

<h2>Calculating the sum</h2>

<p>Now let’s try something harder - calculating a sum of array’s elements. Here we will use the horizontal vector operations. But first, here’s the general algorithm:</p>
<span class="kt">float</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p>Simple enough, huh? Now let’s use the SSE’s <code>_mm_add_ps</code> intrinsic. Running it on each pack of four elements will give us the summary vector of four floats:</p>
<span class="kt">float</span> <span class="nf">sum_sse</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="n">__m128</span> <span class="o">*</span><span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__m128</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">__m128</span> <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">v4</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p>But if we now add the elements of that vector horizontally to themselves, we would then have the two-element vector. Adding it to itself will give us the final single-element vector:</p>
<span class="kt">float</span> <span class="nf">sum_sse</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="n">__m128</span> <span class="o">*</span><span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__m128</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">__m128</span> <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_setzero_ps</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">v4</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">);</span>
    <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_hadd_ps</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">);</span>

    <span class="n">_mm_store_ss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p>Nice, isn’t it? But wait! Integers are available too! And they need their special intrinsics! Have no fear, nothing that different here, only the prefixes are different:</p>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">sum4</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">res</span><span class="p">;</span>

    <span class="n">__m128i</span> <span class="o">*</span><span class="n">f4</span> <span class="o">=</span> <span class="p">(</span><span class="n">__m128i</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">__m128i</span> <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_setzero_si128</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_hadd_epi32</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">f4</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_hadd_epi32</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">);</span>
    <span class="n">vec_sum</span> <span class="o">=</span> <span class="n">_mm_hadd_epi32</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">);</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_mm_cvtsi128_si32</span><span class="p">(</span><span class="n">vec_sum</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<p>And, just to approve our assumption of speeding-up, here’s the benchmarking <u>(on one million of elements)</u>:</p>
Value-based: 0.00853100 <span class="o">(</span>500245.28125000<span class="o">)</span>
SSE: 0.00319800 <span class="o">(</span>500243.50000000<span class="o">)</span>
Value-based on integers: 0.00773100 <span class="o">(</span>49453512<span class="o">)</span>
SSE on integers: 0.00274800 <span class="o">(</span>49453512<span class="o">)</span>

<h2>Limitations?</h2>

<p>Please note the difference between sums calculated with naive loop and the one calculated with SSE: <strong>they do differ</strong>. This is caused by a way computer work nowadays. Actually, how they store floating-point values. Since computers deal with binary system, they can not simply store all those digits after point in the memory and operate on them effectively.</p>

<p>Remember, how integers are stored in a binary system? Say, 14:</p>

<p>+-----------+------------------------+
    |     n     | 5   4   3   2   1   0  |
    +------------------------------------+
    | pow(2, n) | 32  16  8   4   2   1  |
    +------------------------------------+
    |   fits?   | N   N   Y   Y   Y   N  |
    +------------------------------------+
    |   14  =   | 0 + 0 + 8 + 4 + 2 + 0  |
    +-----------+------------------------+
    | bin(14) = | 0   0   1   1   1   0  |
    +-----------+------------------------+</p>

<p>E.g. binary representation of <code>14</code> is: <code>14<sub>2</sub> = 001110</code>. Leading zeroes could be skipped in a binary system <u>(as there might be as many of those as you wish)</u>.</p>

<p>A similar thing happens to floating-point numbers: the difference is that computer stores the negative powers of two:</p>

<p>+------------+-----------------------------------------+
    |     n      | 5        4       3      2     1    0    |
    +------------------------------------------------------+
    | pow(2, -n) | 0.03125  0.0625  0.125  0.25  0.5  1.0  |
    +------------------------------------------------------+
    |   fits?    | N        N       Y      Y      Y    N   |
    +------------------------------------------------------+
    |   0.9  =   | 0    +   0  +  0.125 + 0.25 + 0.5 + 0   |
    +------------------------------------------------------+
    | bin(0.9) = | 0        0       1      1      1    0   |
    +------------------------------------------------------+</p>

<p>As you can see, using 5 bits is not enough to represent 0.9, but only <code>0.875</code>. Even if we use 32 bits <u>(which is just a <code>float</code> data type in C)</u>, we will have <code>0.011001100110011001100110011001110<sub>2</sub></code>, which is <code>0.8999999999068677</code>, but still, it&#39;s not exactly what we wanted. On 64 bits <u>(<code>double</code> type in C)</u> it is better, <code>0.8999999999999999</code>, but, again, not exact value. And if we try adding one million unprecise numbers, we will probably get the unprecise result.</p>

<p>Another big limitation of SSE is that initial data should be aligned to contain the number of elements, which is a multiply of either 2 or 4 <u>(depending on the SSE operation type you are using - scalar or double)</u>.</p>

<h2>Resources</h2>

<ol>
<li><a href="http://www.slideshare.net/mkurnosov/3-code-vectorization-sse-avx">Code vectorization with SSE</a></li>
<li><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">Intel intrinsics guide</a></li>
<li><a href="https://github.com/shybovycha/sse-optimizations">Examples source code</a></li>
</ol>
