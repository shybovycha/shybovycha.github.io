<meta name="layout" content="post">
<meta name="title" content="Loooong lists with Clojure">
<meta name="categories" content="">
<meta name="tags" content="">
<meta name="published" content="true">
<meta name="date" content="2015-10-16T18:11:39+01:00">
<h2>Whaaaaat?</h2>

<p>These days I was given a reeeeally interesting homework at the university. I was given a set of
MD5 hashes, calculated from single words <em>(taken from Libre Office&#39; dictionaries)</em> with a given
sault. And the task was to find all those words.</p>

<p>So, the first idea which came to my mind was using an internet service for MD5 breaking. But...
aaarrrggghhh! There&#39;s a sault, so the webservice, looking for words over a dictionary fails to
find mines...</p>

<p>So the second idea was to take that dictionary from Libre Office and iterate through it. At the
end, it worked =) And worked reeeally fast. But that is not an interesting part.</p>

<p>I wandered if I could find those words in my dictionary, generated by my own code.</p>

<!--more-->

<h2>Hoooow?</h2>

<p>I was thinking of writing it functionally. Really functionally, in Clojure. And, highly motivated
by how good Clojure is at parallelism <em>(sarcasm?..)</em>, I started thinking. After many tries and
even installing Clojure REPL on my phone and writing code all the way home from university and work,
I asked my dear friend to help me with this.</p>

<p>And so we went non-functional way first... We wrote a Java class, having two methods for generating
words recursively. The idea was, to make a new word by appending it with each letter, then appending
each of the alphabet&#39; letters to this word and so on, until we get all the words of <code>N</code> characters.</p>

<p><img data-src="/images/looong-tasks-with-clojure/collaborative-java.png" class="img-responsive" style="max-height: 150px" /></p>

<p>When our pretty class was created and working <em>(for some cases)</em>, we decided to do it more
Java-correct and created two more classes, implementing a single interface, doing the same thing
but differently each. And decided to skip writing <code>context.xml</code> and going deeper with Spring =)</p>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.*</span><span class="o">;</span>

<span class="kd">interface</span> <span class="nc">IWordGenerator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MooWordGenerator</span> <span class="kd">implements</span> <span class="nc">IWordGenerator</span> <span class="o">{</span>
    <span class="c1">// Best practices in naming convention =)</span>

    <span class="cm">/** not necessary */</span>
    <span class="kd">public</span> <span class="nf">MooWordGenerator</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">completeWords</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">cs</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Object:</span><span class="o">:</span><span class="n">toString</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">());</span> <span class="c1">// what the fuuck???</span>

            <span class="n">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>

            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">ncs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

            <span class="n">ncs</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span>
            <span class="n">ncs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

            <span class="n">completeWords</span><span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ncs</span><span class="o">,</span> <span class="n">words</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">cs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="n">completeWords</span><span class="o">(</span><span class="n">length</span><span class="o">,</span> <span class="n">cs</span><span class="o">,</span> <span class="n">words</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">words</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">FooWordGenerator</span> <span class="kd">implements</span> <span class="nc">IWordGenerator</span> <span class="o">{</span>
    <span class="cm">/** */</span>
    <span class="kd">private</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">;</span>
    <span class="cm">/** */</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">;</span>

    <span class="cm">/**
     * Creates list of strings containing all possible words with given length.
     *
     * @param length - the length of words to generate.
     * @return List&lt;String&gt; words.
     *
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">allWords</span> <span class="o">=</span> <span class="n">getAllWords</span><span class="o">(</span><span class="n">length</span><span class="o">);</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">words</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">allWords</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Creates list of strings containing all possible words with given length.
     * Possible to run this method ONLY ONCE! Next calls will
     * give the wrong result.
     *
     * @param length - the length of words to generate.
     * @return List&lt;String&gt; words.
     *
     */</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getAllWords</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'c'</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">//doesn't work</span>
            <span class="n">getSB</span><span class="o">().</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">getSB</span><span class="o">().</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">getAllWords</span><span class="o">(</span><span class="n">length</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">getWords</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">getSB</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span>

            <span class="n">getSB</span><span class="o">().</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">getSB</span><span class="o">().</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="nf">getWords</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Get string builder. create new if null.
     * @return sb.
     */</span>
    <span class="kd">private</span> <span class="nc">StringBuilder</span> <span class="nf">getSB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sb</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">sb</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Get words array. create new if null.
     * @return words.
     */</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">getWords</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">words</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">words</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/** D: go smoke
         *
         *
         *
         *
         **/</span>
        <span class="nc">IWordGenerator</span> <span class="n">gen1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MooWordGenerator</span><span class="o">();</span>
        <span class="nc">IWordGenerator</span> <span class="n">gen2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FooWordGenerator</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Moo:"</span><span class="o">);</span>

        <span class="n">gen1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="na">stream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Foo:"</span><span class="o">);</span>

        <span class="n">gen1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="na">stream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<p>The solution was made. It worked reaaaally loooooong for words with six letters. I decided to start
working on Clojure implementation of this idea. I started writing a function, generating a list of
words. <em>Word</em> in this code was represented by a list of numbers from 0 to 25, associated with
corresponding letters of latin alphabet. That allowed me not to bore myself with generating a
list of chars and use a built-in Clojure&#39; <code>range</code> function.</p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">gen-words</span><span class="w"> </span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="n">cs</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w">
        </span><span class="n">cs</span><span class="w">
        </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">gen-words</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">cs</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">26</span><span class="p">))))</span><span class="w">
</span>
<p>But ended up with the same results as for Java on six letters. Moreover, my implementation
gave me strangely-nested list, which caused writing special flattening functions; Clojure&#39;s
<code>flatten</code> gave me a plain list, where all the words were merged with others.</p>

<p>I needed performance boost!</p>

<p>I tried using <code>pmap</code> instead of <code>map</code> to parallelize the list generation process, but that
did not helped. I also tried generating a list of <code>future</code> objects, so each list element will be
calculated only when needed:</p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">gen-words</span><span class="w"> </span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="n">cs</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w">
        </span><span class="n">cs</span><span class="w">
        </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">gen-words</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">cs</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">26</span><span class="p">))))</span><span class="w">
</span>
<p>But that caused my futures never to be finished. And then my collegue reminded me I can create
a function, which will only rely on a previously generated word and will return the next one,
not a list of words. <em>&quot;That might save me lot of memory!&quot;</em>, I thought and started coding.</p>

<p>And finished with this pretty implementation:</p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">next-word</span><span class="w"> </span><span class="p">[</span><span class="n">prev-word</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="nb">drop-while</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="n">prev-word</span><span class="p">)</span><span class="w">
            </span><span class="n">l-size</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">prev-word</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w">
            </span><span class="n">zeroes</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="n">l-size</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
            </span><span class="n">new-head</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w">
            </span><span class="n">new-tail</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w">
        </span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">zeroes</span><span class="w"> </span><span class="p">[</span><span class="n">new-head</span><span class="p">]</span><span class="w"> </span><span class="n">new-tail</span><span class="p">)))</span><span class="w">
</span>
<p>See, in this implementation no word is being saved nowhere except the return value or an
input argument <em>(well, actually the output from a function is then being used as an input
for itself)</em>.</p>

<p>I converted all the word representations into words with this over-complicated function:</p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">word-to-str</span><span class="w"> </span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">char</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="sc">\a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">int</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w"> </span><span class="n">w</span><span class="p">)))</span><span class="w">
</span>
<p>And then I created a function, generating a list of those words.</p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">words</span><span class="w">
    </span><span class="p">([</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">words</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
    </span><span class="p">([</span><span class="n">n</span><span class="w"> </span><span class="n">w</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">str-w</span><span class="w"> </span><span class="p">(</span><span class="nf">word-to-str</span><span class="w"> </span><span class="n">w</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w">
                </span><span class="p">[</span><span class="n">str-w</span><span class="p">]</span><span class="w">
                </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">str-w</span><span class="w"> </span><span class="p">(</span><span class="nf">words</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nf">next-word</span><span class="w"> </span><span class="n">w</span><span class="p">))))))))</span><span class="w">
</span>
<p>Yeah, again! But not a plain list or vector, as previously, nooo. I generated a lazy-sequence!
This is where Clojure meets ES6 generators =) See, lazy sequence in Clojure is a <em>(possibly)</em> endless
collection, each element of which could be evaluated <em>(or assigned a value)</em> when it is
needed. Besides that, collection takes almost no memory and its creation costs almost
no time. Saying <em>almost</em> I mean the time, needed to construct and store an object in memory.
Just a simple, plain class&#39; instance.</p>

<p>But that was not an option - it took nearly <code>45 minutes</code> to find all the 6-letter words even
when using <code>pmap</code> and eaten SO much damn memory!..</p>

<p><img class="img-responsive" style="max-height: 150px" src="/images/looong-tasks-with-clojure/mem-consumption-1.png" /></p>

<p>However, idle REPL eats much memory too:</p>

<p><img class="img-responsive" style="max-height: 150px" src="/images/looong-tasks-with-clojure/idle-repl-memory.png" /></p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">seq-contains?</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="w"> </span><span class="n">target</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">some</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">coll</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">decode-1</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">ws</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">seq-contains?</span><span class="w"> </span><span class="n">input-hashes</span><span class="w"> </span><span class="p">(</span><span class="nf">encode</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">words</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nf">pmap</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">w</span><span class="w"> </span><span class="p">(</span><span class="nf">encode</span><span class="w"> </span><span class="n">w</span><span class="p">)])</span><span class="w"> </span><span class="n">ws</span><span class="p">)))</span><span class="w">
</span>
<p>Then I enhanced this implementation eliminating the <code>lazy-seq</code> completely. So, there was no
collection creation at all! All the results were printed onto screen right away when found.
This could be replaced with any other storage - file, database, anything! Printing results
on the screen is a habit from my student years...</p>
<span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">decode-2</span><span class="w">
    </span><span class="p">([</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">decode-2</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
    </span><span class="p">([</span><span class="n">n</span><span class="w"> </span><span class="n">prev-word</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="n">prev-word-str</span><span class="w"> </span><span class="p">(</span><span class="nf">word-to-str</span><span class="w"> </span><span class="n">prev-word</span><span class="p">)</span><span class="w">
            </span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">seq-contains?</span><span class="w"> </span><span class="n">input-hashes</span><span class="w"> </span><span class="p">(</span><span class="nf">encode</span><span class="w"> </span><span class="n">prev-word-str</span><span class="p">))</span><span class="w">
                </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">encode</span><span class="w"> </span><span class="n">prev-word-str</span><span class="p">)</span><span class="w"> </span><span class="n">prev-word-str</span><span class="p">)</span><span class="w">
                </span><span class="n">nil</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="n">prev-word</span><span class="p">)</span><span class="w">
                </span><span class="n">nil</span><span class="w">
                </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nf">next-word</span><span class="w"> </span><span class="n">prev-word</span><span class="p">))))))</span><span class="w">
</span>
<p>The memory consumption got minimal:</p>

<p><img class="img-responsive" style="max-height: 150px" src="/images/looong-tasks-with-clojure/mem-consumption-2.png" /></p>

<p>And the time consumption was not <strong>that</strong> good, though...</p>
<span class="n">task1.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">time</span><span class="w"> </span><span class="p">(</span><span class="nf">decode-2</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="mi">4</span><span class="n">adbc43d3e1b432aea5e657cd57016de</span><span class="w"> </span><span class="n">rampa</span><span class="w">
</span><span class="n">bba60169d41b2dce7d0b37b2f9d637e0</span><span class="w"> </span><span class="n">kolej</span><span class="w">
</span><span class="mi">7914</span><span class="n">da949837cbdecf35cbf5951ad518</span><span class="w"> </span><span class="n">argon</span><span class="w">
</span><span class="s">"Elapsed time: 92879.138203 msecs"</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span>
<p>Running it from non-REPL environment helped a bit:</p>
╰─<span class="nv">$ </span>lein run
4adbc43d3e1b432aea5e657cd57016de rampa
bba60169d41b2dce7d0b37b2f9d637e0 kolej
7914da949837cbdecf35cbf5951ad518 argon
<span class="s2">"Elapsed time: 73796.575567 msecs"</span>

<h2>Profit?</h2>

<p><em>But where&#39;s the Saint Graal for brute-forcing like that? How to speed that algorithm?</em>
I don&#39;t know, actually =) Well, I know how to do it with <em>OpenMP</em>, I have a couple of
ideas on how this task could be distributed, but those desire a separate article.</p>
