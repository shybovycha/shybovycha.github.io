<meta name="layout" content="post">
<meta name="title" content="First application">
<meta name="date" content="2015-08-27T18:05:00+01:00">
<h2>Install Irrlicht</h2>

<p>First of all, you will definetely need the Irrlicht engine, so
<a href="http://irrlicht.sourceforge.net/downloads/"><strong>go get it</strong></a>.</p>

<p>Then you will need to compile it. Compilation process depends on the operating system you use,
but it&#39;s really similar on every one.</p>

<h3>Linux</h3>

<p>Install these dependencies with your system&#39; package manager:
<code>libenet-dev libxxf86vm-dev zlib-dev cmake</code>.</p>

<p>Unzip Irrlicht, go to the directory you unpacked with the terminal and run the following:</p>
<span class="nb">cd source</span>/Irrlicht
make

<p>Belive it or not, but that&#39;s all!</p>

<h3>Windows</h3>

<p>Unzip Irrlicht, go to the directory you unpacked and open the VisualStudio project <u>(depending on
VisualStudio version, you might want to open a bit different file)</u> in <code>source/Irrlicht</code>:</p>
Irrlicht10.0.sln
Irrlicht11.0.sln
Irrlicht8.0.sln
Irrlicht9.0.sln

<p>Build it with VisualStudio - and you are done!</p>

<h3>MacOS X</h3>

<p>The steps are a bit complicated. And they require you to install <strong>XCode</strong> and
<strong>Command-Line Tools</strong> - those could be found either in  AppStore or on the Apple
website.</p>

<ul>
<li><p>First of all, you need to install a bunch of dependencies <u>(I use <code>brew</code> for this purpose)</u>:</p>
brew <span class="nb">install </span>tinyxml enet lua cmake</li>
<li><p>Get a list of all compilers available for your OSX version:</p></li>
</ul>
  xcodebuild <span class="nt">-showBuildSettings</span> | <span class="nb">grep </span>DEFAULT_COMPILER

<p>I got something like this:</p>
  <span class="nv">$ </span>xcodebuild <span class="nt">-showBuildSettings</span> | <span class="nb">grep </span>DEFAULT_COMPILER
    DEFAULT_COMPILER <span class="o">=</span> com.apple.compilers.llvm.clang.1_0

<ul>
<li>Now the build process:</li>
</ul>
  <span class="nb">cd source</span>/Irrlicht/MacOSX
  xcodebuild <span class="nt">-project</span> MacOSX.xcodeproj <span class="nv">GCC_VERSION</span><span class="o">=</span>com.apple.compilers.llvm.clang.1_0

<ul>
<li>And the final step - copy the library to the <code>lib/MacOSX</code> directory:</li>
</ul>
  <span class="nb">cp </span>build/Release/libIrrlicht.a ../../../lib/MacOSX

<p>Phew! That&#39;s a damn bunch of commands, don&#39;t you think?</p>

<!--more-->

<h3>Common</h3>

<p>By performing those steps, described above, you will end up with the compiled Irrlicht library file
within the <code>lib/</code> directory, depending on your platform:</p>
Linux/libIrrlicht.a
MacOSX/libIrrlicht.a
Win32-visualstudio/Irrlicht.lib
Win64-visualStudio/Irrlicht.lib

<p>Now, create a blank project in your favorite IDE and proceed...</p>

<h2>Application itself</h2>

<p>Our first application will show you Irrlicht basic features we will use later. They are:</p>

<ul>
<li><strong>mesh handling</strong> - loading, rendering, animating, etc.</li>
<li><strong>user input handling</strong> - reacting to keyboard and mouse events</li>
<li><strong>user interface (UI)</strong> - displaying some information within the application window</li>
</ul>

<p>The good start for that is standard example from Irrlicht pack, the <strong>04 - Movement</strong> one.
Let&#39;s take a look over its code:</p>
<span class="cm">/** Example 004 Movement

This Tutorial shows how to move and animate SceneNodes. The
basic concept of SceneNodeAnimators is shown as well as manual
movement of nodes using the keyboard.  We'll demonstrate framerate
independent movement, which means moving by an amount dependent
on the duration of the last run of the Irrlicht loop.

Example 19.MouseAndJoystick shows how to handle those kinds of input.

As always, I include the header files, use the irr namespace,
and tell the linker to link with the .lib file.
*/</span>
<span class="cp">#ifdef _MSC_VER
</span><span class="c1">// We'll also define this to stop MSVC complaining about sprintf().</span>
<span class="cp">#define _CRT_SECURE_NO_WARNINGS
#pragma comment(lib, "Irrlicht.lib")
#endif
</span>
<span class="cp">#include &lt;irrlicht.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">irr</span><span class="p">;</span>

<span class="cm">/*
To receive events like mouse and keyboard input, or GUI events like "the OK
button has been clicked", we need an object which is derived from the
irr::IEventReceiver object. There is only one method to override:
irr::IEventReceiver::OnEvent(). This method will be called by the engine once
when an event happens. What we really want to know is whether a key is being
held down, and so we will remember the current state of each key.
*/</span>
<span class="k">class</span> <span class="nc">MyEventReceiver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEventReceiver</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// This is the one method that we have to implement</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">OnEvent</span><span class="p">(</span><span class="k">const</span> <span class="n">SEvent</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Remember whether each key is down or up</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">EventType</span> <span class="o">==</span> <span class="n">irr</span><span class="o">::</span><span class="n">EET_KEY_INPUT_EVENT</span><span class="p">)</span>
            <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">event</span><span class="p">.</span><span class="n">KeyInput</span><span class="p">.</span><span class="n">Key</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">KeyInput</span><span class="p">.</span><span class="n">PressedDown</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// This is used to check whether a key is being held down</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">IsKeyDown</span><span class="p">(</span><span class="n">EKEY_CODE</span> <span class="n">keyCode</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">keyCode</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">MyEventReceiver</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u32</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">KEY_KEY_CODES_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="c1">// We use this array to store the current state of each key</span>
    <span class="kt">bool</span> <span class="n">KeyIsDown</span><span class="p">[</span><span class="n">KEY_KEY_CODES_COUNT</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*
The event receiver for keeping the pressed keys is ready, the actual responses
will be made inside the render loop, right before drawing the scene. So lets
just create an irr::IrrlichtDevice and the scene node we want to move. We also
create some other additional scene nodes, to show that there are also some
different possibilities to move and animate scene nodes.
*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// create device</span>
    <span class="n">MyEventReceiver</span> <span class="n">receiver</span><span class="p">;</span>

    <span class="n">IrrlichtDevice</span><span class="o">*</span> <span class="n">device</span> <span class="o">=</span> <span class="n">createDevice</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">EDT_OPENGL</span><span class="p">,</span>
            <span class="n">core</span><span class="o">::</span><span class="n">dimension2d</span><span class="o">&lt;</span><span class="n">u32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">receiver</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// could not create selected driver.</span>

    <span class="n">video</span><span class="o">::</span><span class="n">IVideoDriver</span><span class="o">*</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getVideoDriver</span><span class="p">();</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">ISceneManager</span><span class="o">*</span> <span class="n">smgr</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getSceneManager</span><span class="p">();</span>

    <span class="cm">/*
    Create the node which will be moved with the WSAD keys. We create a
    sphere node, which is a built-in geometry primitive. We place the node
    at (0,0,30) and assign a texture to it to let it look a little bit more
    interesting. Because we have no dynamic lights in this scene we disable
    lighting for each model (otherwise the models would be black).
    */</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addSphereSceneNode</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setMaterialTexture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">"../../media/wall.bmp"</span><span class="p">));</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setMaterialFlag</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">EMF_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
    Now we create another node, movable using a scene node animator. Scene
    node animators modify scene nodes and can be attached to any scene node
    like mesh scene nodes, billboards, lights and even camera scene nodes.
    Scene node animators are not only able to modify the position of a
    scene node, they can also animate the textures of an object for
    example. We create a cube scene node and attach a 'fly circle' scene
    node animator to it, letting this node fly around our sphere scene node.
    */</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addCubeSceneNode</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">setMaterialTexture</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">"../../media/t351sml.jpg"</span><span class="p">));</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">setMaterialFlag</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">EMF_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNodeAnimator</span><span class="o">*</span> <span class="n">anim</span> <span class="o">=</span>
            <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">createFlyCircleAnimator</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">),</span> <span class="mf">20.0</span><span class="n">f</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">anim</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">n</span><span class="o">-&gt;</span><span class="n">addAnimator</span><span class="p">(</span><span class="n">anim</span><span class="p">);</span>
            <span class="n">anim</span><span class="o">-&gt;</span><span class="n">drop</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*
    The last scene node we add to show possibilities of scene node animators is
    a b3d model, which uses a 'fly straight' animator to run between to points.
    */</span>
    <span class="n">scene</span><span class="o">::</span><span class="n">IAnimatedMeshSceneNode</span><span class="o">*</span> <span class="n">anms</span> <span class="o">=</span>
        <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addAnimatedMeshSceneNode</span><span class="p">(</span><span class="n">smgr</span><span class="o">-&gt;</span><span class="n">getMesh</span><span class="p">(</span><span class="s">"../../media/ninja.b3d"</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">anms</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNodeAnimator</span><span class="o">*</span> <span class="n">anim</span> <span class="o">=</span>
            <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">createFlyStraightAnimator</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">60</span><span class="p">),</span>
            <span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">60</span><span class="p">),</span> <span class="mi">3500</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">anim</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">anms</span><span class="o">-&gt;</span><span class="n">addAnimator</span><span class="p">(</span><span class="n">anim</span><span class="p">);</span>
            <span class="n">anim</span><span class="o">-&gt;</span><span class="n">drop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="cm">/*
        To make the model look right we disable lighting, set the
        frames between which the animation should loop, rotate the
        model around 180 degrees, and adjust the animation speed and
        the texture. To set the right animation (frames and speed), we
        would also be able to just call
        "anms-&gt;setMD2Animation(scene::EMAT_RUN)" for the 'run'
        animation instead of "setFrameLoop" and "setAnimationSpeed",
        but this only works with MD2 animations, and so you know how to
        start other animations. But a good advice is to not use
        hardcoded frame-numbers...
        */</span>
        <span class="n">anms</span><span class="o">-&gt;</span><span class="n">setMaterialFlag</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">EMF_LIGHTING</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

        <span class="n">anms</span><span class="o">-&gt;</span><span class="n">setFrameLoop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
        <span class="n">anms</span><span class="o">-&gt;</span><span class="n">setAnimationSpeed</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="c1">//      anms-&gt;setMD2Animation(scene::EMAT_RUN);</span>

        <span class="n">anms</span><span class="o">-&gt;</span><span class="n">setScale</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mf">2.</span><span class="n">f</span><span class="p">,</span><span class="mf">2.</span><span class="n">f</span><span class="p">,</span><span class="mf">2.</span><span class="n">f</span><span class="p">));</span>
        <span class="n">anms</span><span class="o">-&gt;</span><span class="n">setRotation</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="c1">//      anms-&gt;setMaterialTexture(0, driver-&gt;getTexture("../../media/sydney.bmp"));</span>

    <span class="p">}</span>

    <span class="cm">/*
    To be able to look at and move around in this scene, we create a first
    person shooter style camera and make the mouse cursor invisible.
    */</span>
    <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addCameraSceneNodeFPS</span><span class="p">();</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">getCursorControl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

    <span class="cm">/*
    Add a colorful irrlicht logo
    */</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addImage</span><span class="p">(</span>
        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getTexture</span><span class="p">(</span><span class="s">"../../media/irrlichtlogoalpha2.tga"</span><span class="p">),</span>
        <span class="n">core</span><span class="o">::</span><span class="n">position2d</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">));</span>

    <span class="n">gui</span><span class="o">::</span><span class="n">IGUIStaticText</span><span class="o">*</span> <span class="n">diagnostics</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addStaticText</span><span class="p">(</span>
        <span class="s">L""</span><span class="p">,</span> <span class="n">core</span><span class="o">::</span><span class="n">rect</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
    <span class="n">diagnostics</span><span class="o">-&gt;</span><span class="n">setOverrideColor</span><span class="p">(</span><span class="n">video</span><span class="o">::</span><span class="n">SColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="cm">/*
    We have done everything, so lets draw it. We also write the current
    frames per second and the name of the driver to the caption of the
    window.
    */</span>
    <span class="kt">int</span> <span class="n">lastFPS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// In order to do framerate independent movement, we have to know</span>
    <span class="c1">// how long it was since the last frame</span>
    <span class="n">u32</span> <span class="n">then</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getTimer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTime</span><span class="p">();</span>

    <span class="c1">// This is the movemen speed in units per second.</span>
    <span class="k">const</span> <span class="n">f32</span> <span class="n">MOVEMENT_SPEED</span> <span class="o">=</span> <span class="mf">5.</span><span class="n">f</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Work out a frame delta time.</span>
        <span class="k">const</span> <span class="n">u32</span> <span class="n">now</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getTimer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTime</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">f32</span> <span class="n">frameDeltaTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">f32</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">then</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span><span class="n">f</span><span class="p">;</span> <span class="c1">// Time in seconds</span>
        <span class="n">then</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

        <span class="cm">/* Check if keys W, S, A or D are being held down, and move the
        sphere node around respectively. */</span>
        <span class="n">core</span><span class="o">::</span><span class="n">vector3df</span> <span class="n">nodePosition</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">getPosition</span><span class="p">();</span>

        <span class="k">if</span><span class="p">(</span><span class="n">receiver</span><span class="p">.</span><span class="n">IsKeyDown</span><span class="p">(</span><span class="n">irr</span><span class="o">::</span><span class="n">KEY_KEY_W</span><span class="p">))</span>
            <span class="n">nodePosition</span><span class="p">.</span><span class="n">Y</span> <span class="o">+=</span> <span class="n">MOVEMENT_SPEED</span> <span class="o">*</span> <span class="n">frameDeltaTime</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">receiver</span><span class="p">.</span><span class="n">IsKeyDown</span><span class="p">(</span><span class="n">irr</span><span class="o">::</span><span class="n">KEY_KEY_S</span><span class="p">))</span>
            <span class="n">nodePosition</span><span class="p">.</span><span class="n">Y</span> <span class="o">-=</span> <span class="n">MOVEMENT_SPEED</span> <span class="o">*</span> <span class="n">frameDeltaTime</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">receiver</span><span class="p">.</span><span class="n">IsKeyDown</span><span class="p">(</span><span class="n">irr</span><span class="o">::</span><span class="n">KEY_KEY_A</span><span class="p">))</span>
            <span class="n">nodePosition</span><span class="p">.</span><span class="n">X</span> <span class="o">-=</span> <span class="n">MOVEMENT_SPEED</span> <span class="o">*</span> <span class="n">frameDeltaTime</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">receiver</span><span class="p">.</span><span class="n">IsKeyDown</span><span class="p">(</span><span class="n">irr</span><span class="o">::</span><span class="n">KEY_KEY_D</span><span class="p">))</span>
            <span class="n">nodePosition</span><span class="p">.</span><span class="n">X</span> <span class="o">+=</span> <span class="n">MOVEMENT_SPEED</span> <span class="o">*</span> <span class="n">frameDeltaTime</span><span class="p">;</span>

        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">nodePosition</span><span class="p">);</span>

        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">beginScene</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">video</span><span class="o">::</span><span class="n">SColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">113</span><span class="p">,</span><span class="mi">113</span><span class="p">,</span><span class="mi">133</span><span class="p">));</span>

        <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">drawAll</span><span class="p">();</span> <span class="c1">// draw the 3d scene</span>
        <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">drawAll</span><span class="p">();</span> <span class="c1">// draw the gui environment (the logo)</span>

        <span class="n">driver</span><span class="o">-&gt;</span><span class="n">endScene</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">fps</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getFPS</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lastFPS</span> <span class="o">!=</span> <span class="n">fps</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">core</span><span class="o">::</span><span class="n">stringw</span> <span class="n">tmp</span><span class="p">(</span><span class="s">L"Movement Example - Irrlicht Engine ["</span><span class="p">);</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="s">L"] fps: "</span><span class="p">;</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="n">fps</span><span class="p">;</span>

            <span class="n">device</span><span class="o">-&gt;</span><span class="n">setWindowCaption</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
            <span class="n">lastFPS</span> <span class="o">=</span> <span class="n">fps</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*
    In the end, delete the Irrlicht device.
    */</span>
    <span class="n">device</span><span class="o">-&gt;</span><span class="n">drop</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
That's it. Compile and play around with the program.
**/</span>

<h2>Building the project</h2>

<p>Paste the code from above to your blank project in your IDE, in the <code>source/main.cpp</code> file.
This may differ, but is not critical. Now, add the <code>CMakeLists.txt</code> file to your project
and fill it with these commands:</p>
<span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.1<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>irrlicht_newton_game1<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -std=c++11"</span><span class="p">)</span>

<span class="nb">find_package</span><span class="p">(</span>X11<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>OpenGL<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>ZLIB<span class="p">)</span>

<span class="nb">if</span> <span class="p">(</span>NOT IRRLICHT_LIBRARY_PATH<span class="p">)</span>
    <span class="nb">find_library</span><span class="p">(</span>IRRLICHT_LIBRARY_PATH
            NAMES Irrlicht
            PATHS <span class="si">${</span><span class="nv">IRRLICHT_PATH</span><span class="si">}</span>/lib/
            PATH_SUFFIXES Linux MacOSX Win32-gcc Win32-visualstudio Win64-visualstudio<span class="p">)</span>

    <span class="nb">message</span><span class="p">(</span>STATUS <span class="s2">"Found Irrlicht: </span><span class="si">${</span><span class="nv">IRRLICHT_LIBRARY_PATH</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">IRRLICHT_PATH</span><span class="si">}</span>/include<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>SOURCE_FILES source/main.cpp<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>EXECUTABLE_NAME irrlicht_newton_game1<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span> <span class="si">${</span><span class="nv">SOURCE_FILES</span><span class="si">}</span><span class="p">)</span>

<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">IRRLICHT_LIBRARY_PATH</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">X11_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">OPENGL_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">ZLIB_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">X11_Xxf86vm_LIB</span><span class="si">}</span><span class="p">)</span>

<p><strong>Note:</strong> for those of you, guys, running MacOS X I prepared a bit more complicated
<code>CMakeLists.txt</code> file - just to make our application run everywhere:</p>
<span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.1<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>irrlicht_newton_game1<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -std=c++11"</span><span class="p">)</span>

<span class="nb">option</span><span class="p">(</span><span class="s2">"NEWTON_DEMOS_SANDBOX"</span> <span class="s2">"Build demos sandbox"</span> OFF<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>LUACPPINTERFACE_PATH source/luacppinterface-master<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CPPFORMAT_PATH source/cppformat-master<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>NEWTONGD_PATH source/newton-dynamics-master<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>NEWTONGD_INCLUDE_DIRS
        <span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span>/packages/dCustomJoints
        <span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span>/packages/dContainers
        <span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span>/packages/dMath<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>NEWTON_LIBRARIES Newton dMath<span class="p">)</span>

<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">LUACPPINTERFACE_PATH</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">CPPFORMAT_PATH</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span><span class="p">)</span>

<span class="nb">find_package</span><span class="p">(</span>X11<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>OpenGL<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>ZLIB<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>Lua<span class="p">)</span>

<span class="nb">if</span> <span class="p">(</span>NOT IRRLICHT_LIBRARY_PATH<span class="p">)</span>
    <span class="nb">if</span> <span class="p">(</span>UNIX<span class="p">)</span>
        <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX Linux<span class="p">)</span>
    <span class="nb">endif</span><span class="p">()</span>

    <span class="nb">if</span> <span class="p">(</span>APPLE<span class="p">)</span>
        <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX MacOSX<span class="p">)</span>
    <span class="nb">endif</span><span class="p">()</span>

    <span class="nb">if</span> <span class="p">(</span>WIN32<span class="p">)</span>
        <span class="nb">if</span> <span class="p">(</span>MSVC<span class="p">)</span>
            <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX Win32-visualstudio Win64-visualstudio<span class="p">)</span>
        <span class="nb">endif</span><span class="p">()</span>

        <span class="nb">if</span> <span class="p">(</span>MINGW<span class="p">)</span>
            <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX Win32-gcc<span class="p">)</span>
        <span class="nb">endif</span><span class="p">()</span>
    <span class="nb">endif</span><span class="p">()</span>

    <span class="nb">find_library</span><span class="p">(</span>IRRLICHT_LIBRARY_PATH
            NAMES Irrlicht
            PATHS <span class="si">${</span><span class="nv">IRRLICHT_PATH</span><span class="si">}</span>/lib/
            PATH_SUFFIXES <span class="si">${</span><span class="nv">IRRLICHT_PATH_SUFFIX</span><span class="si">}</span><span class="p">)</span>

    <span class="nb">message</span><span class="p">(</span>STATUS <span class="s2">"Found Irrlicht: </span><span class="si">${</span><span class="nv">IRRLICHT_LIBRARY_PATH</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<span class="nb">set</span><span class="p">(</span>LIBRARIES luacppinterface
        cppformat
        <span class="si">${</span><span class="nv">NEWTON_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">IRRLICHT_LIBRARY_PATH</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">X11_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">OPENGL_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">ZLIB_LIBRARIES</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">LUA_LIBRARIES</span><span class="si">}</span><span class="p">)</span>

<span class="nb">if</span> <span class="p">(</span>NOT APPLE<span class="p">)</span>
    <span class="nb">set</span><span class="p">(</span>LIBRARIES <span class="si">${</span><span class="nv">LIBRARIES</span><span class="si">}</span> <span class="si">${</span><span class="nv">X11_Xxf86vm_LIB</span><span class="si">}</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">IRRLICHT_PATH</span><span class="si">}</span>/include
        <span class="si">${</span><span class="nv">LUA_INCLUDE_DIR</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">LUACPPINTERFACE_PATH</span><span class="si">}</span>/include
        <span class="si">${</span><span class="nv">CPPFORMAT_PATH</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">NEWTONGD_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>SOURCE_FILES source/main.cpp<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>EXECUTABLE_NAME irrlicht_newton_game1<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span> <span class="si">${</span><span class="nv">SOURCE_FILES</span><span class="si">}</span><span class="p">)</span>

<span class="nb">if</span> <span class="p">(</span>APPLE<span class="p">)</span>
    <span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -framework Foundation -framework OpenGL -framework Cocoa -framework Carbon -framework AppKit -framework IOKit"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">LIBRARIES</span><span class="si">}</span><span class="p">)</span>

<h2>CMake file</h2>

<p>But what happens in all that code? First two lines of our <code>CMakeLists.txt</code> file define the project:</p>
<span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.1<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>irrlicht_newton_game1<span class="p">)</span>

<p>Then we modify the variable <code>CMAKE_CXX_FLAGS</code>, which will be used to set compiler flags.
This is how we add items to lists or modify string variables with CMake: we set it the new
value, consisting of the old one and the new elements / parts:</p>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -std=c++11"</span><span class="p">)</span>

<p>Then we tell CMake not to build <em>Newton demo sandbox</em> subproject and set a few path variables -
we will use them to point compiler to the header and library files of our third-party libraries
(like Newton itself, Irrlicht and others).</p>

<p><strong>Remember:</strong> these are only plain variables, they have no effect on compiler themselves.</p>
<span class="nb">set</span><span class="p">(</span>LUACPPINTERFACE_PATH source/luacppinterface-master<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CPPFORMAT_PATH source/cppformat-master<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>NEWTONGD_PATH source/newton-dynamics-master<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>NEWTONGD_INCLUDE_DIRS
        <span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span>/packages/dCustomJoints
        <span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span>/packages/dContainers
        <span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span>/packages/dMath<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>NEWTON_LIBRARIES Newton dMath<span class="p">)</span>

<p>Next, we point CMake to our sub-projects, which are by the fact our third-party libraries:</p>
<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">LUACPPINTERFACE_PATH</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">CPPFORMAT_PATH</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span><span class="si">${</span><span class="nv">NEWTONGD_PATH</span><span class="si">}</span><span class="p">)</span>

<p>These tell CMake to build sub-projects before building our application. Because our sub-projects
are nothing but libraries, we can then look for the built libraries, required by our project
in the sub-projects&#39; output directories like this:</p>
<span class="nb">find_package</span><span class="p">(</span>Lua<span class="p">)</span>

<p>Same way we look for system libraries:</p>
<span class="nb">find_package</span><span class="p">(</span>X11<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>OpenGL<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>ZLIB<span class="p">)</span>

<p>These commands set compile-ready variables like <code>X11_LIBRARIES</code>.</p>

<p>Some sub-projects may set CMake variables too, providing us with paths to include files or
library files. If Irrlicht did not do this, we try to find its paths with CMake:</p>
<span class="nb">if</span> <span class="p">(</span>NOT IRRLICHT_LIBRARY_PATH<span class="p">)</span>
    <span class="nb">if</span> <span class="p">(</span>UNIX<span class="p">)</span>
        <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX Linux<span class="p">)</span>
    <span class="nb">endif</span><span class="p">()</span>

    <span class="nb">if</span> <span class="p">(</span>APPLE<span class="p">)</span>
        <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX MacOSX<span class="p">)</span>
    <span class="nb">endif</span><span class="p">()</span>

    <span class="nb">if</span> <span class="p">(</span>WIN32<span class="p">)</span>
        <span class="nb">if</span> <span class="p">(</span>MSVC<span class="p">)</span>
            <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX Win32-visualstudio Win64-visualstudio<span class="p">)</span>
        <span class="nb">endif</span><span class="p">()</span>

        <span class="nb">if</span> <span class="p">(</span>MINGW<span class="p">)</span>
            <span class="nb">set</span><span class="p">(</span>IRRLICHT_PATH_SUFFIX Win32-gcc<span class="p">)</span>
        <span class="nb">endif</span><span class="p">()</span>
    <span class="nb">endif</span><span class="p">()</span>

    <span class="nb">find_library</span><span class="p">(</span>IRRLICHT_LIBRARY_PATH
            NAMES Irrlicht
            PATHS <span class="si">${</span><span class="nv">IRRLICHT_PATH</span><span class="si">}</span>/lib/
            PATH_SUFFIXES <span class="si">${</span><span class="nv">IRRLICHT_PATH_SUFFIX</span><span class="si">}</span><span class="p">)</span>

    <span class="nb">message</span><span class="p">(</span>STATUS <span class="s2">"Found Irrlicht: </span><span class="si">${</span><span class="nv">IRRLICHT_LIBRARY_PATH</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<p>Note the environment variables CMake provides us with: <code>UNIX</code>, <code>APPLE</code>, <code>WIN32</code>, <code>MSVC</code>
and many others. They describe which operating system CMake was ran under and which
compiler it was told to use.</p>

<p>And the most important part of our <code>CMakeLists.txt</code> file:</p>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">IRRLICHT_PATH</span><span class="si">}</span>/include
        <span class="si">${</span><span class="nv">LUA_INCLUDE_DIR</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">LUACPPINTERFACE_PATH</span><span class="si">}</span>/include
        <span class="si">${</span><span class="nv">CPPFORMAT_PATH</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">NEWTONGD_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>SOURCE_FILES source/main.cpp<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>EXECUTABLE_NAME irrlicht_newton_game1<span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span> <span class="si">${</span><span class="nv">SOURCE_FILES</span><span class="si">}</span><span class="p">)</span>

<p>This actually runs the <strong>compiler</strong> with the include directories, source files and
output file specified.</p>

<p>After that, we may run <strong>linker</strong> to link the intermediate object files, provided by
compiler, and end up with the application executable:</p>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span>
        <span class="si">${</span><span class="nv">LIBRARIES</span><span class="si">}</span><span class="p">)</span>

<p>For OSX users there is a small hack, needed to build the application:</p>
<span class="nb">if</span> <span class="p">(</span>APPLE<span class="p">)</span>
    <span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="si">}</span><span class="s2"> -framework Foundation -framework OpenGL -framework Cocoa -framework Carbon -framework AppKit -framework IOKit"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<p><strong>Note the order the commands are specified in:</strong> having include path variables definitions
placed before sub-projects commands may be no harmful, but more <em>&quot;effective&quot;</em> commands,
like compiling sub-projects (<code>add_subdirectory</code>) depend on other CMake commands, so
be sure to keep the order sane and clean.</p>

<h2>Running the build</h2>

<p>Now that you are ready, run the following commands from your project directory
<strong>(you will need <code>cmake</code> to be installed in your system)</strong>:</p>
<span class="nb">mkdir </span>build
<span class="nb">cd </span>build
cmake <span class="nt">-DIRRLICHT_PATH</span><span class="o">=</span>path_to_directory_where_you_unpacked_irrlicht ..
make

<p><strong>Warning:</strong> do not forget to replace <code>path_to_directory_where_you_unpacked_irrlicht</code> with
the actual path to the directory, where your Irrlicht files lay!</p>

<p>This will build our first Irrlicht application. Not obvious how handy it is right now,
but you will see the power of CMake in our later sessions.</p>

<p>Before you run the application, copy the whole <code>media</code> directory from the Irrlicht
dir to the parent dir of your project. You should end up with directory structure like this:</p>
.
└── irrlicht_newton_tutorials
    ├── irrlicht_newton_game1
    │   ├── build
    │   ├── CMakeLists.txt
    │   └── source
    │       └── main.cpp
    └── media

<p><strong>Note:</strong> If you now just run the <code>irrlicht_newton_game1</code> binary on OSX, you will see
your application does not react to keyboard events. This is tricky, but you need
to pack your application as OSX application. This is easy, though: just create
a directory tree <code>mkdir -p irrlicht_newton_game1.app/Contents/MacOS/</code> and move
your binary file there:</p>
├── irrlicht_newton_game1.app
│   └── Contents
│       └── MacOS
│           └── irrlicht_newton_game1

<p>Open <strong>Finder</strong> and run the application from there. On other operating systems run
the executable file in your <code>build</code> directory.</p>

<p>Buuuuut, since we have CMake, we may simplify this task because this is a part of
application build process. So we need to create a usual binary file, when we are
running Linux or Windows or create a directory structure with binary on its deepest
level, when running OSX. CMake allows to do it in a really easy way:</p>
<span class="nb">if</span> <span class="p">(</span>APPLE<span class="p">)</span>
    <span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span> MACOSX_BUNDLE <span class="si">${</span><span class="nv">SOURCE_FILES</span><span class="si">}</span><span class="p">)</span>
<span class="nb">else</span><span class="p">()</span>
    <span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">EXECUTABLE_NAME</span><span class="si">}</span> <span class="si">${</span><span class="nv">SOURCE_FILES</span><span class="si">}</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<p>You should see something like this:</p>

<p><img data-src="/images/04_movement_untouched.png"></p>

<p>To end the process you may consider switching to a terminal and running</p>
pkill irrlicht_newton_game1

<h2>Understanding the code</h2>

<p>Here are few simple things we could extract from application&#39; code and understand right from scratch:</p>

<ul>
<li>Each 3D model is a <u>scene node</u></li>
<li>Primitive scene nodes (such as <u>cube</u> or <u>sphere</u>) could be easily created with built-in functions:</li>
</ul>
  <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addSphereSceneNode</span><span class="p">();</span>
  <span class="n">scene</span><span class="o">::</span><span class="n">ISceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addCubeSceneNode</span><span class="p">();</span>

<ul>
<li>Animated 3D models (such as <u>character models</u>) could be loaded from file:</li>
</ul>
  <span class="n">scene</span><span class="o">::</span><span class="n">IAnimatedMeshSceneNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">addAnimatedMeshSceneNode</span><span class="p">(</span><span class="n">smgr</span><span class="o">-&gt;</span><span class="n">getMesh</span><span class="p">(</span><span class="s">"../../media/ninja.b3d"</span><span class="p">));</span>

<p><strong>Hint:</strong> if mesh is animated, animation could be started with:</p>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setFrameLoop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setAnimationSpeed</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>

<p><strong>Hint:</strong> animation could be stopped with setting its speed to zero:</p>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">setAnimationSpeed</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<ul>
<li>Node could be described not only by its vertices and indices <u>(forming a set of triangles which are drawn
in 3D forming a model, called <strong>mesh</strong>)</u> but by its <strong>position</strong>, <strong>rotation</strong> and <strong>scale</strong></li>
</ul>

<p>Those could be set with:</p>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">setPosition</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">setRotation</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="n">x_angle</span><span class="p">,</span> <span class="n">y_angle</span><span class="p">,</span> <span class="n">z_angle</span><span class="p">));</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">setScale</span><span class="p">(</span><span class="n">core</span><span class="o">::</span><span class="n">vector3df</span><span class="p">(</span><span class="n">width_factor</span><span class="p">,</span> <span class="n">height_factor</span><span class="p">,</span> <span class="n">depth_factor</span><span class="p">));</span>

<p><strong>Hint:</strong> rotation is a set of angles relatively to the corresponding axes, the node will be rotated
    around. E. g., <code>vector3df(45, 90, 0)</code> sets the rotation by <code>45 deg</code> around <code>X axis</code>, <code>90 deg</code> around <code>Y axis</code>
    and no rotation aroung <code>Z axis</code>. All those axes are relative to the node itself.</p>

<p><img data-src="/images/irrlicht-newton-tutorials/euler_angles.jpg"></p>

<ul>
<li><p>Graphics User Interface&#39; <u>(GUI)</u> widgets for information output are labels; they are created with
<strong>GUI Manager</strong>:</p>
<span class="n">gui</span><span class="o">::</span><span class="n">IGUIStaticText</span><span class="o">*</span> <span class="n">label</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">getGUIEnvironment</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addStaticText</span><span class="p">(</span><span class="s">L""</span><span class="p">,</span> <span class="n">core</span><span class="o">::</span><span class="n">rect</span><span class="o">&lt;</span><span class="n">s32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span></li>
</ul>

<p><strong>Hint:</strong> its text could be set with:</p>

<p><code>cpp
    label-&gt;setText((const wchar_t*) &quot;some text&quot;);
</code></p>

<ul>
<li>User input is handled by an external <code>IEventReceiver</code> class object.</li>
</ul>

<p>Its method,</p>

<p><code>cpp
    virtual bool OnEvent(const SEvent&amp; event)
</code></p>

<p>defines the logic of handling events like <u>mouse events</u>, <u>keyboard events</u>, <u>joystick events</u>,
    <u>GUI events</u>, etc.</p>

<p>The type of event is passed with the <code>event.EventType</code> field. The corresponding field is filled
    with the event parameters.</p>

<p>For example:</p>
  <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">EET_MOUSE_INPUT_EVENT</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">MouseInput</span><span class="p">.</span><span class="n">isLeftPressed</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d is cursor position</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">event</span><span class="p">.</span><span class="n">MouseInput</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">event</span><span class="p">.</span><span class="n">mouseInput</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

<p><strong>Hint:</strong> <code>EventReceiver</code> object has nothing in common with our main game loop. So we should create
    some interface, some architecture trick to link those two. Because they are strongly related!</p>

<ul>
<li>Main game loop should contain <strong>rendering call</strong>, <strong>GUI rendering call</strong> and other game logic processing
calls.</li>
</ul>

<p>The simplest main loop could look like this:</p>

<p>```cpp
    while (device-&gt;run()) {
        driver-&gt;beginScene(true, true, video::SColor(255, 113, 113, 133));</p>

<p>smgr-&gt;drawAll(); // draw the 3d scene
        device-&gt;getGUIEnvironment()-&gt;drawAll(); // draw the gui</p>

<p>driver-&gt;endScene();
    }
    ```</p>

<ul>
<li>There is no simple <u>(or at least, built-in)</u> way to get the delta time between two rendered frames.
<strong>This is an important variable!</strong> We&#39;ll need that later, when we inject physics engine. And Newton GD
is not the only engine requiring this variable!</li>
</ul>

<p>But that could be easily done with this workaround:</p>

<p>```cpp
    // before main loop
    u32 then = device-&gt;getTimer()-&gt;getTime();</p>

<p>// ...</p>

<p>// within the main game loop
    const u32 now = device-&gt;getTimer()-&gt;getTime();
    const f32 frameDeltaTime = (f32)(now - then) / 1000.f; // delta time in seconds
    then = now;
    ```</p>

<p>That was some short introduction to the Irrlicht engine. And that&#39;s basically everything we will use
for the next few sections.</p>

<p><a href="//irrlicht-newton-tutorials/2015-08-28-first-script " class="btn btn-success">Next chapter</a></p>
