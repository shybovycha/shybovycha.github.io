---
layout: post
title: ReactJS introduction
date: '2015-07-12T00:20:05+02:00'
tags:
- rtfm
- tutorial
- react
- angular
- riot
tumblr_url: http://shybovycha.tumblr.com/post/123838775416/reactjs-introduction
---
<h2>Foreword</h2>

<p>Last time I wrote an article on how one can encapsulate both HTML and CSS in one
entity, called WebComponent. This time I want to tell a bit about how to encapsulate
JavaScript and HTML.</p>

<p>When I see an article on <a href="http://habrahabr.ru">Habrahabr</a> titled <em>React something</em>,
I think <em>Omg, React again?..</em>. But React, just as Ember was always a mystery for me.</p>

<p>Until today.</p>

<!--more-->

<p>I&rsquo;ve read an awesome article, <a href="http://reactfordesigners.com/labs/reactjs-introduction-for-people-who-know-just-enough-jquery-to-get-by/?utm_source=javascriptweekly&amp;utm_medium=email"><em>React.js Introduction For People Who Know Just Enough jQuery To Get By</em></a>.
And now I really see the power of React. Though, I am still planning to play with Angular 2.0 and
still remain a fan of Angular, I can tell you for sure, React may help you to raise your level
if you are still writing your web-sites with jQuery.</p>

<p>React is a way to make your project consist of a components. So, for example, you have a complex webpage.
You may then have a layout, styled in a way to support different themes. Then you may split all its partials
into components, so you do not need your layout to hardly rely on its partials.</p>

<p>Although building components with react may seem polluting your code with HTML, it is really great concept to
keep your HTML code near the JS code handling it. React has its own restrictions for the components.
For example, you can not use two tags alongside inside your component. It is required to use
<strong>exactly</strong> one top-level tag. And all the variables are stored in the <code>state</code> variable.
But I will tell you how to overcome that restriction later.</p>

<h2>The architecture</h2>

<p>This article relies on JavaScript, so let&rsquo;s be kind and create an initial project structure for
a typical JS project. Just like this:</p>

<p><img src="https://40.media.tumblr.com/963c862fc4d835d180a4bb6e5dfdfd9c/tumblr_inline_nrcgsc8eei1qh5oee_540.png" alt="Project structure"/></p>

<p>This is always great to have a typical structure for a project so anyone new to the project will
not get lost.</p>

<p>So, we can assume we will always have a set of javascripts and stylesheets, used on a front-end.
We also may need some third-party libraries, managed by NPM or Bower. And this is <strong>always</strong>
<em>(I mean not javascript projects only)</em> a great idea to have your changes being tracked by some
version control system. I like Git the most.</p>

<p>Based on those few assumptions, we will need a folder with <code>javascripts</code> and <code>stylesheets</code> sub-dirs;
<code>.gitignore</code>, <code>package.json</code> and <code>bower.json</code> files <em>(select those you need)</em>.</p>

<p>In some cases, like with this article, we may need to compile some of resources. For that purpose we
may create something like <code>build</code> directory. And define the build command in <code>package.json</code> file, within
the <code>scripts</code> section.</p>

<h2>A very simple introduction</h2>

<h3>Preparing layout template</h3>

<p>So, let&rsquo;s start writing a layout for our sample webpage. This may be done with <a href="http://emmet.io/"><strong>Emmet</strong></a>.
Just type <code>html:5</code> and press <code>Tab</code> within your favorite text editor <em>(I feel comfortable with both
Sublime and Atom, yet you may run Emacs and still use Emmet)</em>.</p>

<h3>Front-end dependencies</h3>

<p>Now, let&rsquo;s add <code>bootstrap</code> and <code>react</code> scripts. The good way of doing it is using <a href="http://bower.io/"><strong>bower</strong></a>.
Now there are two ways of adding dependencies with bower: manually editing <code>bower.json</code> or using command-line.</p>

<p>If you decided to add dependencies into <code>bower.json</code> file, remember to set the concrete versions for each dependency.
Or you may face situations, when someone installs your project and uses the newer versions of libraries, which are
incompatible with the code, which uses them.</p>

<p>Here are the lines you will need to add to your <code>bower.json</code> file to proceed:</p>

{% highlight js %}
  "dependencies": {
    // ...
    "react": "0.13.3",
    "bootstrap": "3.3.5"
  }
{% endhighlight %}

<p>If you have chosen the CLI way, consider this command:</p>

<pre><code>
  bower install --save bootstrap react
</code></pre>

<p>I preferred the CLI way as it chooses the correct libraries&rsquo; versions automatically.</p>

<p>Now you may add React&rsquo;s javascript and Bootstrap&rsquo;s CSS into the layout:</p>

{% highlight html %}
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8">
      <title>Introduction to ReactJS</title>

      <script src="bower_components/react/react.min.js"></script>

      <link href="bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
    </body>
  </html>
{% endhighlight %}

<h3>First NPM task</h3>

<p>You may want to add a task to your <code>package.json</code> to install bower dependencies automatically:</p>

{% highlight json %}
  {
    "dependencies": {
      "bower": "1.4.1"
    }
    "scripts": {
      "bower": "./node_modules/bower/bin/bower install"
    }
  }
{% endhighlight %}

<p>This may be useful later, when building a project. Here I used the local version of bower in the script
to not make another project requirement of globally installed bower.
This approach is used lately in this article for building task.</p>

<h3>JSX vs JavaScript</h3>

<p>React uses <strong>JSX</strong>. JSX has two meanings. Accordingly to <a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS#static-typing"><em>List of languages that compile to JS</em></a>, JSX
is an extension of JavaScript with human-friendly OOP and type safety support. In the universe of React,
JSX is an extension of JavaScript too. But in this case, JSX only allows to create DOM elements from within the
code in a DSL-style.</p>

<p>To explain what is DSL-style, I shall show you two examples:</p>

<p><strong>non-DSL way:</strong></p>

{% highlight js %}
  React.createElement("div", {className: "well clearfix"},
    React.createElement("textarea", {className: "form-control", onChange: this.handleChange}),
    React.createElement("br", null),
    React.createElement("button", {className: "btn btn-primary pull-right"}, "Tweet")
  )
{% endhighlight %}

<p><strong>DSL way:</strong></p>

{% highlight js %}
  return (
    <div className="well clearfix">
      <textarea className="form-control" onChange={this.handleChange}></textarea>
      <br/>
      <button className="btn btn-primary pull-right">Tweet</button>
    </div>
  );
{% endhighlight %}

<p>Both of JSX branches are, again, extensions to JavaScript, thus they need to be compiled to ES5 <em>(also known as
 &ldquo;usual javascript&rdquo;)</em> to make the code understood by browser. For this purpose we need a compiler.
For React this is called <code>react-tools</code>. So let&rsquo;s add it as a dependency inside our project&rsquo;s <code>package.json</code> file.
This will add the <code>jsx</code> utility to the <code>node_modules</code> sub-dir. So we may define another build task within
the <code>package.json</code> file:</p>

<pre><code>
  {
    "scripts": {
      "build": "./node_modules/react-tools/bin/jsx src/javascripts/ build/"
    }
  }
</code></pre>

<p>This task compiles all the scripts from the <code>src/javascripts/</code> directory and stores the compiled javascripts in
<code>build/</code> directory.</p>

<h3>First component</h3>

<p>All components are made simply calling <code>React.createClass()</code> method and providing it with a component&rsquo;s rendering
method <em>(a method that returns component&rsquo;s HTML)</em>, its initial <strong>state</strong> <em>(something like Angular&rsquo;s <code>$scope</code>)</em> and
event handlers. Just check it out:</p>

{% highlight js %}
  var TweetBox = React.createClass({
    render: function() {
      return (
        <div className="well clearfix">
          <textarea className="form-control"></textarea>
          <br/>
          <button className="btn btn-primary pull-right">Tweet</button>
        </div>
      );
    }
  });
{% endhighlight %}

<p>Here you may see a few restricts, done by React:</p>

<ol><li>you need <strong>exactly</strong> one top-level tag for your component</li>
<li>you may not use <code>class</code> attribute within elements, use <code>className</code> instead</li>
</ol><p>And this is how this component is used:</p>

<pre><code>
  React.render(
    &lt;TweetBox /&gt;,
    document.body
  );
</code></pre>

<p>Note: you may not use the <code>&lt;TweetBox /&gt;</code> tag from within the HTML.</p>

<p>Now let&rsquo;s write that component within the <code>javascripts/app.js</code> file and reference it in the layout,
at the end of <code>&lt;body&gt;</code> tag; to make it loaded when all the document is done loading:</p>

{% highlight html %}
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8">
      <title>Introduction to ReactJS</title>

      <script src="bower_components/react/react.min.js"></script>

      <link href="bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
      <script src="build/app.js"></script>
    </body>
  </html>
{% endhighlight %}

<p>To see the page we&rsquo;ve written in action, first compile the sources with <code>npm run build</code> to compile
the JSX code to javascript and use it in the layout template.</p>

<h3>State</h3>

<p>The component&rsquo;s internals are stored within the <code>state</code> variable. This is something like Angular&rsquo;s <code>$scope</code>.
React adds a method to initialize your component&rsquo;s state, called <code>getInitialState()</code>. It should return object,
representing the initial state. State variables may be accessed via <code>this.state.myVar</code> and interpolated
in template with curly-braces syntax, <code>{this.state.myVar}</code>. So you may do something like this:</p>

{% highlight js %}
  var TweetBox = React.createClass({
    getInitialState: function() {
      return {
        text: "",
        maxLength: 140
      }
    },
    render: function() {
      return (
        <div className="well clearfix">
          <textarea className="form-control"></textarea>
          <br/>
          <span>{ this.state.maxLength - this.state.text.length }</span>
          <button className="btn btn-primary pull-right">Tweet</button>
        </div>
      );
    }
  });
{% endhighlight %}

<p>State may be changed with the <code>setState()</code> method, receiving&hellip; object! But this time, the object for <code>setState()</code>
represents a set of new field values. So, for example, using syntax</p>

<pre><code>
  this.setState({ text: "newValue" });
</code></pre>

<p>will not replace the whole state with <code>text</code> field only. Instead, it will modify <code>text</code> field only and will left
<code>maxLength</code> unchanged.</p>

<p>But when can we call the <code>changeState()</code>? In Angular it is done with <strong>data binding</strong>. But in React we have
events. Yes-yes, simple DOM events!</p>

<p>So, for example, we may set the <code>onChange</code> event in the <code>&lt;textarea rows="10" cols="50"&gt;</code> and just handle it:</p>

<pre><code>
  var TweetBox = React.createClass({
    ...
    handleChange: function(evt) {
      this.setState({ text: evt.target.value });
    },
    render: function() {
      ...
      &lt;textarea className="form-control" onChange={ this.handleChange }&gt;
      ...
    }
</code></pre>

<p>Yeah, looks not so pretty as with Angular&hellip;</p>

<h3>React: conclusion</h3>

<p>I assume React&rsquo;s way of doing websites is nice until you learn something better. At least,
when switching from jQuery, you can make your webpage&rsquo;s code look much better with React!</p>

<h2>Alternatives</h2>

<h3>Riot</h3>

<p>But wait! There are alternatives! <a href="https://muut.com/riotjs/"><strong>Riot</strong></a> continues React experience of state. But makes
it with a much more pretty code. But the main advantage of Riot is ES6. Yeah, when both of libraries
use compilation, why reject the future and invent a wheel? Thus Riot makes your code much more clear. Check this out:</p>

{% highlight html %}
  <tweet-box>
    <div class="well clearfix">
      <textarea class="form-control" onkeyup={ handleChange }></textarea>
      <br/>
      <span>{ maxLength - text.length }</span>
      <button class="btn btn-primary pull-right">Tweet</button>
    </div>

    <script>
      this.text = "";
      this.maxLength = 140;

      handleChange(evt) {
        this.text = evt.target.value;
      }
    </script>
  </tweet-box>
{% endhighlight %}

<p>Everything looks great with Riot: its size is much more lower than React&rsquo;s; it has ES6 and nice syntax; it does not
turn your JS code into substance on the edge of two worlds - <strong>views layer</strong> and <strong>logic layer</strong>; it has even
<a href="https://muut.com/riotjs/guide/#scoped-css"><strong>scoped css</strong></a>!..</p>

<p>But Riot has one huge drawback. That drawback is <code>XHTTPRequest</code>. By default, you <strong>may</strong> define your components
inline, just within your layout page. But as long as it is a mix of HTML and JS, browser will not correctly
respond to your page, throwing you strange exceptions. So, you may decide to extract your components into separate files.
But here you may face the fact that most of modern browsers do not allow for asynchronous requests to the files
without protocol being provided <em>(so you can not load project files via AJAX while testing project locally)</em>.
And that&rsquo;s how Riot loads your components - via AJAX. So you need either to pre-compile your components or
run your project on a web server.</p>

<h3>Angular 2.0</h3>

<p>Great news for each and every AngularJS fan; the essence of future of web development, <a href="https://angular.io"><strong>Angular.js 2.0</strong></a>.
It is made with <a href="http://www.typescriptlang.org/"><strong>TypeScript</strong></a>, which is even more powerful than ES6. It
provides developers with component architecture - HTML and JS encapsulation, but in even more sophisticated form.</p>

<p>So, for example, our &lt;tweet-box&gt; component in Angular 2.0 may look like this:</p>

<p><strong>tweet-box.ts:</strong></p>

{% highlight java %}
  /// <reference path="../typings/angular2/angular2.d.ts" />
  import {Component, View, bootstrap, formDirectives} from 'angular2/angular2';

  @Component({
    selector: 'tweet-box'
  })
  @View({
    directives: [formDirectives],
    templateUrl: 'src/tweet-box.html'
  })
  class TweetBox {
    text: string;
    maxLength: integer;

    constructor() {
      this.maxLength = 140;
      this.text = '';
    }
  }

  bootstrap(TweetBox);
{% endhighlight %}

<p><strong>tweet-box.html:</strong></p>

{% highlight mustache %}
  <div class="well clearfix">
    <textarea class="form-control" [(ng-model)]="text"></textarea>
    <br/>
    <span>{{ maxLength - text.length }}</span>
    <button class="btn btn-primary pull-right">Tweet</button>
  </div>
{% endhighlight %}

<p>Here, as you can see, data binding is used, so there is no more need in event handling. And you can use
all the power of TypeScript. But still, the great Angular 2.0 drawbacks are:</p>

<ol><li>Angular 2.0 is still on the <strong>alpha</strong> stage <em>(at least, while I am writing this post, it is)</em></li>
<li>too much effort is needed to get it working <em>(because of p. 1; still, THREE dependency managers to get it work is way too much&hellip;)</em></li>
<li>it still needs the server to serve templates or using templates inline</li>
<li>there are some major differences with all of the other libs referenced here, which may be hard to get used to <em>(for ex., using formDirectories like <code>[(ng-model)]="modelName"</code>)</em></li>
</ol><h2>Fin</h2>

<p>Looking at those three libraries, I can tell that Riot made my day. It is as simple as powerful and small. It lacks for two-way
data binding, but makes much more sense than React. And yet does not require you to get mad installing all those
dependencies to make it work.</p>

<p>All the examples, mentioned in the article are on my GitHub account:</p>

<ul><li><a href="https://github.com/shybovycha/intro-to-react">React example</a></li>
<li><a href="https://github.com/shybovycha/intro-to-riot">Riot example</a></li>
<li><a href="https://github.com/shybovycha/intro-to-angular2">Angular 2.0 example</a>
</li>
</ul>
